<html>
<head>
    <title>Ex 9.2 Hints</title>
    <link rel="stylesheet" type="text/css" href="../../css/simple.css">
</head>
<body>
<h2>Hints for Exercise 9.2</h2>

<h3>pi.py</h3>

<font color="grey"><pre>    # TODO: define an empty set of Future instances named `futures`</font>
<font color="blue">    futures = set()</pre></font>

<font color="grey"><pre>    # TODO: write a `with` statement to use a ProcessPoolExecutor.
    # with ThreadPoolExecutor(max_workers=ntasks) as executor:</font>
<font color="blue">    with ProcessPoolExecutor() as executor:</pre></font>

<font color="grey"><pre>        # TODO: set up a `for` loop that executes 4 times.</font>
<font color="blue">        for _ in range(4):</pre></font>

<font color="grey"><pre>            # TODO: for each loop iteration, use a Process to execute
            # sample_multiple with the argument chunk_size.
            # Save the returned Future in a local variable.</font>
<font color="blue">            future = executor.submit(sample_multiple, chunk_size)</pre></font>

<font color="grey"><pre>            # TODO: add the returned Future to the `futures` set.</font>
<font color="blue">            futures.add(future)</pre></font>

<font color="grey"><pre>    # TODO: set up a `for` loop to get the result of each process as it
    # completes.</font>
<font color="blue">    for future in concurrent.futures.as_completed(futures):</font>

<font color="grey">        # TODO: add the process's result to `hits`</font>
<font color="blue">        hits += future.result()</pre></font>

<font color="grey"><pre>
    # Add calls to timeit here </font><font color="blue">

    from timeit import timeit

    time = timeit('pi_async()',
                  setup='from __main__ import pi_async',
                  number=1)
    print('pi_async execution time:', time)

    time = timeit('pi_serial()',
                  setup='from __main__ import pi_serial',
                  number=1)
    print('pi_serial execution time:', time)
</pre></font>

<h2>Hints for Exercise 9.2 Bonus (Comparing threads and processes)</h2>

<h3>pi.py</h3>

<font color="grey"><pre>
Replace the ProcessPoolExecutor with a ThreadPoolExecuter: </font><font color="blue">

    with ThreadPoolExecutor(max_workers=4) as executor:  
</pre></font>

<h2>Hints for Exercise 9.2 Bonus (Managing parallel subprocesses)</h2>

<h3>encrypt.py</h3>

<font color="grey"><pre># TODO: import Process from the multiprocessing module</font>
<font color="blue">from multiprocessing import Process</pre></font>

<font color="grey"><pre>    for file in sys.argv[1:]:
        # TODO: create a Process instance to execute the run_openssl() function</font><font color="blue">
        child_process = Process(target=run_openssl,
                                args=(file, env))</pre></font>

<font color="grey"><pre>        # TODO: start the Process instance</font>
<font color="blue">        child_process.start()</pre></font>

<h2>Hints for Exercise 9.2 Bonus (Compare concurrent and parallelized news feed readers)</h2>

<h3>all_news_feed_reader.py</h3>

<font color="grey"><pre>
# TODO: import ThreadPoolExecutor from concurrent.futures </font><font color="blue">
from concurrent.futures import ThreadPoolExecutor
</pre></font>

<font color="grey"><pre>
        # TODO: wrap the `for` loop in a `with` statement that initializes
        # a ThreadPoolExecutor. Pass the argument max_workers=4 to the
        # ThreadPoolExecutor constructor.  </font><font color="blue">
        with ThreadPoolExecutor(max_workers=4) as executor: </font><font color="grey">
            for news_type in 'concerts', 'sports', 'movies':
                # TODO: replace the call to the Thread constructor with a
                # call to executor.submit().
                # Arguments to submit: AllNewsFeedReader.worker, self,
                #                      results_q, news_type, max_items
                # Assign the Future returned by submit to the variable
                # `background` </font><font color="blue">
                background = executor.submit(AllNewsFeedReader.worker, self,
                                             results_q, news_type, max_items) </font><font color="grey">
                news_threads.append(background)

                # TODO: delete the call to background.start() </font><font color="blue">
                # background.start() </font><font color="grey">

        # TODO: in the following `for` statement, replace `news_threads` with
        # a call to concurrent.futures.as_completed(news_threads) </font><font color="blue">
        for thread in concurrent.futures.as_completed(news_threads): </font><font color="grey">
            # TODO: replace the call to thread.join() with `pass` </font><font color="blue">
            pass
</pre></font>

</body>
</html>
