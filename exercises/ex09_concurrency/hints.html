<html>
<head>
<title>Ex 9.1 Hints</title>
<link rel="stylesheet" type="text/css" href="../../css/simple.css">
</head>
<body>
<h2>Hints for Exercise 9.1</h2>

<h3>chat_server.py</h3>

<font color="grey"><pre>
class ChatServer(BaseRequestHandler): </font><font color="blue">
    chat_sockets_lock = Lock() </font><font color="grey">
    chat_sockets = set()
</pre></font>

<font color="grey"><pre>
    def handle(self): </font><font color="blue">
        with ChatServer.chat_sockets_lock: </font><font color="grey">
            ChatServer.chat_sockets.add(self.request) </font><font color="grey">
        try:
            while True:
                ... </font><font color="blue">
                with ChatServer.chat_sockets_lock: </font><font color="grey">
                    for socket in ChatServer.chat_sockets:
                        if socket != self.request:
                            socket.send(msg)
        except ConnectionError: 
            pass
        finally: </font><font color="blue">
            with ChatServer.chat_sockets_lock: </font><font color="grey">
               ChatServer.chat_sockets.remove(self.request)
            ...
</pre></font>

<font color="grey"><pre>
    @classmethoddef shutdown(cls): </font><font color="blue">
        with cls.chat_sockets_lock: </font><font color="grey">
            for socket in cls.chat_sockets:
                ...
</pre></font>

<h2>Hints for Exercise 9.1 Bonus (Managing subprocesses with the subprocess module)</h2>

<h3>encrypt.py</h3>

<font color="grey"><pre># TODO: import Process from the multiprocessing module</font>
<font color="blue">from multiprocessing import Process</pre></font>

<font color="grey"><pre>    for file in sys.argv[1:]:
        # TODO: create a Process instance to execute the run_openssl() function</font><font color="blue">
        child_process = Process(target=run_openssl,
                                args=(file, env))</pre></font>

<font color="grey"><pre>        # TODO: start the Process instance</font>
<font color="blue">        child_process.start()</pre></font>

<h2>Hints for Exercise 9.1 Bonus (Write a multithreaded RSS feed reader)</h2>

<h3>all_news_feed_reader.py</h3>

<font color="grey"><pre>
        # all_news = {}
        # for news_type in 'concerts', 'sports', 'movies':
        #     news = self.feed_reader.get_news(news_type, max_items)
        #     all_news[news_type] = news
        # return all_news
        # TODO: comment out the 5 lines of code above this comment
</pre></font>

<font color="grey"><pre>
        # TODO: create a Queue to hold the news from each thread. Assign
        # the Queue to a variable named `results_q` </font><font color="blue">
        results_q = queue.Queue()
</pre></font>

<font color="grey"><pre>
        # TODO: assign an empty list to the variable named `news_threads`.
        # The `news_threads` list will contain references to the Thread objects
        # that are downloading the news. </font><font color="blue">
        news_threads = []
</pre></font>

<font color="grey"><pre>
        for news_type in 'concerts', 'sports', 'movies':
            # TODO: Create a thread to download one type of news.
            # target: AllNewsFeedReader.worker (you'll write this method soon)
            # args: self, results_q, news_type, max_items </font><font color="blue">
            background = Thread(target=AllNewsFeedReader.worker,
                                args=(self, results_q,
                                      news_type, max_items))
</pre></font>

<font color="grey"><pre>
            # TODO: Append the new thread to the `news_threads` list </font><font color="blue">
            news_threads.append(background)
</pre></font>

<font color="grey"><pre>
            # TODO: Start the new thread </font><font color="blue">
            background.start()
</pre></font>

<font color="grey"><pre>
        # TODO: use a `for` loop to process each thread on the `news_threads`
        # list </font><font color="blue">
        for thread in news_threads: </font><font color="grey">

            # TODO: wait for the thread to complete by calling
            # the thread's join() method </font><font color="blue">
            thread.join()
</pre></font>

<font color="grey"><pre>
        # TODO: loop over `results_q` </font><font color="blue">
        while not results_q.empty(): </font><font color="grey">

            # TODO: get the thread's result (a TypedNews object) from
            # `results_q` and assign it to a variable named `typed_news` </font><font color="blue">
            typed_news = results_q.get_nowait()
</pre></font>


<font color="grey"><pre>
            # TODO: add the data in `typed_news` to the `all_news` dictionary
            # key: the `news_type` attribute of `typed_news`
            # value: the `news` attribute of `typed_news` </font><font color="blue">
            all_news[typed_news.news_type] = typed_news.news
</pre></font>

<font color="grey"><pre>
        # TODO: return the `all_news` dictionary </font><font color="blue">
        return all_news
</pre></font>

<font color="grey"><pre>
    def worker(self, results_q, news_type, max_items):
        # TODO: use `self.feed_reader` to fetch news of the given `news_type`
        # and assign the result to a variable named `news` </font><font color="blue">
        news = self.feed_reader.fetch_news_items(news_type, max_items) </font><font color="grey">

        # TODO: create a TypedNews object and save the result in a local
        # variable. </font><font color="blue">
        typed_news = TypedNews(news_type, news) </font><font color="grey">

        # TODO: put the typed_news object on `results_q` </font><font color="blue">
        results_q.put(typed_news)
</pre></font>

</body>
</html>
